𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡

A python CLI golf simulator.
/home/jh/Documents/Programming/GolfCommand/src/ui


𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡 is designed to be a project that introduces python to beginning developer with zero prior coding experience. 



𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡 is a game heavily inspired by classic text-based games like The Oregon Trail and ZORK!



### UI:

The game runs in the terminal, and teaches the student how to create a textual interface, or command-line interface. The interface for 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡 has a max-width 80 characters wide in total, with 4-character-wide margins on the left and right for the main content. The interface will always be centered in the terminal. The interface should be responsive, adjusting automatically to different terminal sizes. When the terminal is smaller than 80 characters, the content should adjust to fit (up to a reasonable minimum width).

The top of the 80-wide interface will have a top-bar that has inverted foreground and background colors, displaying top-level information that the player needs to view.



### Classes:

**Player** - Player class has the following attributes:

- Name (Input by player)
- Bio (Input by player, later generated by LLM in CS 220 project)
- Health (certain events can )
- Strength (used in Swing calculation)
- Speed (to determine how far the player can travel each turn)

**Inventory** - The player will have multiple slots in their golf bag to store inventory, and differnt item types will automatically be saved into different pockets. However, part of the fun of 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡 is that the player can select literally any object from their inventory when selecting a ball or club, allowing for humorous and unexpected results. If the player uses the command CHANGE CLUB (syntax pending), they'll automatically open the Clubs pocket of their golf bag, but also have the option to change pockets and select any object in their inventory. This means that every in-game object will have to have all of the following stats, even if it wouldn't make sense in a normal video game (because 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡 is not a normal game).

- Mass (used to calculate weight)
- Weight (automatically calculated)
- Coefficient of Restitution
- Condition (object health, objects will degrade over-time and eventually break)
- Durability (how quickly the object breaks. Objects also break faster when hit with a more durable object. For example, an egg hit with a hammer will break immediately, while the hammer's condition will barely change. )
- {other stats that will help with accurate physics generation for the Swing command}
- Price (for buying and selling)

**Golf Course**

I need to flesh out my ideas for this still, but each golf course will be procedurally generated. Stick with simple procedural generation for CS 120 first year project. Will be expanded in later years. Each course is also surrounded by an endless forest expanding to infinity in all directions. Player can technically continue traveling North (or any direction), indefinitely. The course will be randomly generated to have a starting tee, different terrain and traps and hazards (which will affect player speed), and a green, along with various scenery that can affect play like trees etc.

- Gravity (in base game, this will always be constant, but in future classes, players will add courses in environments like on the moon, so this will affect things like the weight of objects and the Swing calculation)
- Par (Calculated after course is generated. Calculation should be easy to modify to ensure final game has realistic par generation.)



The project should be written in a way that's very easy to develop and expand. The project should be designed to slowly introduce the students to python, starting with the basics and building on top of them as the game is built. Every aspect of the game should be written in a way that allows for creativity, flexibility, and experimentation form the student. There is no 'correct' way to write golf command, and the course, while teaching the basics and giving the students the tools and knowledge they need to build a fully playable command line game, encourages creative problem solving rather than simply copying and pasting code. This will let the students learn in a hands on way and keep them excited and passionate about the project.



### Gameplay

The player starts the game in the clubhouse with a set amount of money. They can visit the shop and buy items like clubs, balls, effect items like energy drinks, granola bars, beer, etc. Once the player has geared up, the golf course is generated and they're at the starting tee. The select their ball and club. (If they don't have enough items in their inventory, they can LOOK around their environment, or explore the golf course by moving in cardinal directions and LOOK for objects. The game will have random objects, including sticks, rocks, trash, lost golf balls, and many other items that the player can find and interact with in the environment.)



If possible I'd also like to have some NPC golfers automatically playing in the background. We won't draw attention to these background golfers unless the player crosses paths with them, then they can interact with the golfers. Or if an NPC golfer behind the player hits a ball and it lands in the golfer's current space, the game will tell the golfer in the game narration. Same thing if the golfer comes across any npcs, the game will let them know! This is inspired by the Thief in ZORK!  After the golf course is generated, a small group of NPCs will start golfing for a few rounds before the player starts. The NPC



Anyway, once the player has selected their club and ball, if they use the SWING command (or any other synonyms that the student programs in), then we run the Swing calculation (I'll need help developing this, it should have adjustable parameters to fine-tune during playtesting) and we update the position of the ball. This is where 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡 differs from traditional golf simulators. After hitting the ball (or whatever object they're using as the 'ball'), the player has to actually find the ball

Just like ZORK and similar games, the player can move in the cardinal directions. However, the grid is based on the player's speed, which determines how far they move each turn. A higher speed will result in larger grid cells, and a lower speed results in lower grid cells. The player is only aware of objects, npcs, etc inside their grid and adjacent grid cells, and can only directly interact with objects, npcs etc in their current grid cell. So in order to find their ball, they have to explore the game world until they are adjacent to or on the same grid as their lost ball. NPCs follow the same gameplay as the player, each with their own speed, strength, etc. The NPCs select a club and ball (usually selecting standard clubs and balls that make sense in context), swing, and then have to go find their ball. They will use a very simple rule-based AI. After the player has played for a few turns, a new NPC or group of NPCs have a chance to spawn and start a game behind the golfer!



When the player uses the SWING command, the text input bar (which usually is printed at the bottom of the screen as > ), will transform into an 80-character-wide (or terminal-width) strength meter, that quickly moves up and down. The player has to press ENTER to stop the strength meter on their intended swing strength, adding a challenge to controlling the outcome of their swing (this is inspired by many golf games, like Fuji Golf). The meter should have a minimum strenght of 0%, and a max strenght over 100%, allowing for over-shooting, which negativly affects the swing outcome. If the player hits right on 100%, there will be some kind of bonus.

Certain items and player effects will change how the strength meter behaves. some items will make it faster and harder to use, some will make it calmer and slower, simulating more focus and flow. Some items (like beer), may make the strenght meter more erratic rather than smoothly going from 0 to Max. 



After each game, the player is rewarded some money based on how well they played, and can use this money to buy more items from the shop (or haggle with NPCs and buy items off of them!)



### Physics calculation

The physics calculation will use some real-world physics (coefficient of restitution, velocity, wind resistance, etc) without becoming overly complex. It should be designed to be robust enough to create accurate results for any combination of 'club'/'ball' objects (think of a variety of combinations, like hitting a bowling ball with a pool noodle, or hitting an egg with a hammer, etc.)



This project is for a class called CS 120 - Introduction to Designing Python Command Line Games. Next year, in CS 220 - Advanced Python Command Line Game Design, the students will expand on this project.









### Future Proofing 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡 for CS 220

In CS 220, the students will expand their original 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡 game to create a more advanced version of the game called 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡𝙰𝙸. The game should be written in a way where it can easily be expanded on for the features that will be added for 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡𝙰𝙸 in CS 220. 

About 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡𝙰𝙸 (these features do not to be part of the lesson plan, but should be considered when designing the structure of 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡 to ensure it can easily be modified into 𝔊𝔬𝔩𝔣ℭ𝔬𝔪𝔪𝔞𝔫𝔡𝙰𝙸):

- Explores the use of local LLM Mistral-7b-v0.3-Instruct for dynamic narration, command-handling/function calling, and other advanced features. The LLM will act as the 'brain' of the program, similar to the role of a DM in dungeons and dragons.
- The LLM will also dynamically generate items in the shop and environment, outputting the objects stats (physical properties, price, etc.) for realistic in-game interactions.